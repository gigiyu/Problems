/****************************************************************************
45. Permutations    //TOCHECK
[1,2,3]->{[1,2,3],[1,3,2],[2,3,1],[2,1,3],[3,1,2],[]3,2,1}
["abc"]->{"abc","acb","bac","bca","cab","cba"}
Follow up:
    - utilize multithreading
    - hwo wo avoid using a ridiculously large amount of memory?
*/
template<typename T>
class Solution {
public:
    vector<vector<T>> generatePermutation(vector<T> values) {
        if (values.size() == 0) return ret;
        vector<T> path;
        vector<bool> mark(values.size(), false);
        dfs(values, path, mark);
        return ret;
    }
private:
    vector<vector<T>> ret;
    void dfs(const vector<T>& values, vector<T>& path, vector<bool>& mark) {
        if (path.size() == values.size()) {
            ret.push_back(path);
            return;
        }
        for(int i = 0; i < values.size(); i++) {
            if (mark[i] == true) continue;
            path.push_back(values[i]);
            mark[i] = true;
            dfs(values, path, mark);
            path.pop_back();
            mark[i] = false;
        }
    }
};

/****************************************************************************
52. Max Stack   //TOCHECK
Follow up 
    - What are the performance characteristics(space required, speed of the operations compared to O(1) for normal stacks)?
    - How do you handle duplicate elements?
    - What needs to be done to make this structure thread-safe?
*/
template<typename T>
class MaxStack {
public:
    void push(T value) {
        st.push(value);
        if (maxST.empty() || value >= maxST.top()) maxST.push(value);
    }
    T top() {
        return st.top();
    }
    void pop() {
        T ret = st.top();
        st.pop();
        if (!maxST.empty() && ret == maxST.top()) maxST.pop();
    }
    T topMax() {
        return maxST.top();
    }
private:
    stack<T> st;
    stack<T> maxST;
};

/****************************************************************************
35. Multi-dimensional Sum  //TODO
1. Sum of elements of a k-dimensional array
    example: Given object m that holds a 2*2*3 array
    a = [[[3,2,2],[1,5,0]],[[2,0,1],[1,1,-2]]
    arraySum(m, [2,2,3]) = (3+2+2+1+5+0+2+0+1+1+1+-2) = 16;
2. findMin that given an instance of the function class and the range of grid search. 
    return the minimum of the function over that range.
*/
class Solution {
public:
    int arraySum(MultiDimArray m, vector<int>& dimensions) {
        int ret = 0;
        int n = dimensions.size();
        vector<int> idx(n, 0);
        // 000,001,001,010,011,012,100,101,102,110,111,112
        
    }
};

/****************************************************************************
36. Ponds and Islands  //TOCHECK
2d integer array where 1's signify land and 0's signify water
output: the number of "island" in the array where an island is defined as a continuous block of 1's(LRUD)
Follow up:
    - Space and time complexity
    - if you had an array of elevations, how would you count the number of "basins"?
*/
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        if (grid.empty() || grid[0].empty()) return 0;
        int ret = 0;
        for(int i = 0; i < grid.size(); i++) {
            for(int j = 0; j < grid[0].size(); j++) {
                if (grid[i][j] == '1') {
                    dfs(grid, i, j);
                    ret++;
                }
            }
        }
        return ret;
    }
    vector<vector<int>> d = {{-1,0},{1,0},{0,-1},{0,1}};
    void dfs(vector<vector<char>>& maps, int i, int j ) {
        if (i<0 || i >= maps.size() || j < 0 || j >= maps[0].size() || maps[i][j] == '0') return;
        maps[i][j] = '0';
        for(int k = 0; k < 4; k++) {
            dfs(maps, i + d[k][0], j + d[k][1]);
        }
    }
};
/****************************************************************************
37. Message burst processor //TODO
A burst of message is defined as asequence of messages which are surrounded by given "quiet periods"(with no incoming message)
*/
class MessageBurstProcessor {
public:
    MessageBurstProcessor(long quietPeriod) {
    }
//    Identify the last message in each burst.
//    Called in multiple threads concurrently.
//    return true if the message is the last message in a burst
    bool process(Object message) {
        
    }
};
